import NodeCache from 'node-cache';
import Jsona from 'jsona';
import { stringify } from 'qs';
import { useState, useEffect } from 'react';
import { useRouter } from 'next/router';

var cache = new NodeCache();

var getAccessToken = function getAccessToken() {
  try {
    if (!process.env.DRUPAL_CLIENT_ID || !process.env.DRUPAL_CLIENT_SECRET) {
      return Promise.resolve(null);
    }

    var cached = cache.get(CACHE_KEY);

    if (cached == null ? void 0 : cached.access_token) {
      return Promise.resolve(cached);
    }

    var basic = Buffer.from(process.env.DRUPAL_CLIENT_ID + ":" + process.env.DRUPAL_CLIENT_SECRET).toString("base64");
    return Promise.resolve(fetch(process.env.NEXT_PUBLIC_DRUPAL_BASE_URL + "/oauth/token", {
      method: "POST",
      headers: {
        Authorization: "Basic " + basic,
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: "grant_type=client_credentials"
    })).then(function (response) {
      if (!response.ok) {
        throw new Error(response.statusText);
      }

      return Promise.resolve(response.json()).then(function (result) {
        cache.set(CACHE_KEY, result, result.expires_in);
        return result;
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var CACHE_KEY = "NEXT_DRUPAL_ACCESS_TOKEN";

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var buildHeaders = function buildHeaders(_temp2) {
  var _ref = _temp2 === void 0 ? {} : _temp2,
      accessToken = _ref.accessToken,
      _ref$headers = _ref.headers,
      headers = _ref$headers === void 0 ? {
    "Content-Type": "application/json"
  } : _ref$headers;

  try {
    var _temp3 = function _temp3(token) {
      if (token) {
        headers["Authorization"] = "Bearer " + token.access_token;
      }

      return headers;
    };

    return Promise.resolve(accessToken ? _temp3(accessToken) : Promise.resolve(getAccessToken()).then(_temp3));
  } catch (e) {
    return Promise.reject(e);
  }
};
var getJsonApiIndex = function getJsonApiIndex(locale, options) {
  try {
    var url = buildUrl(locale ? "/" + locale + JSONAPI_PREFIX : "" + JSONAPI_PREFIX);

    var _fetch2 = fetch,
        _url$toString2 = url.toString();

    return Promise.resolve(buildHeaders(options)).then(function (_buildHeaders) {
      return Promise.resolve(_fetch2(_url$toString2, {
        headers: _buildHeaders
      })).then(function (response) {
        if (!response.ok) {
          throw new Error(response.statusText);
        }

        return Promise.resolve(response.json());
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var getJsonApiPathForResourceType = function getJsonApiPathForResourceType(type, locale) {
  try {
    return Promise.resolve(getJsonApiIndex(locale)).then(function (index) {
      var _index$links$type;

      return index == null ? void 0 : (_index$links$type = index.links[type]) == null ? void 0 : _index$links$type.href;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var JSONAPI_PREFIX = process.env.DRUPAL_JSONAPI_PREFIX || "/jsonapi";
var dataFormatter = new Jsona();
function deserialize(body, options) {
  if (!body) return null;
  return dataFormatter.deserialize(body, options);
}
function buildUrl(path, params) {
  var url = new URL(path.charAt(0) === "/" ? "" + process.env.NEXT_PUBLIC_DRUPAL_BASE_URL + path : path);

  if (params) {
    // Use instead URLSearchParams for nested params.
    url.search = stringify(params);
  }

  return url;
}
function getPathFromContext(context, prefix) {
  if (prefix === void 0) {
    prefix = "";
  }

  var slug = context.params.slug;
  slug = Array.isArray(slug) ? slug.join("/") : slug; // Handle locale.

  if (context.locale && context.locale !== context.defaultLocale) {
    slug = "/" + context.locale + "/" + slug;
  }

  return !slug ? process.env.DRUPAL_FRONT_PAGE : prefix ? prefix + "/" + slug : slug;
}
function syncDrupalPreviewRoutes(path) {
  if (window && window.top !== window.self) {
    window.parent.postMessage({
      type: "NEXT_DRUPAL_ROUTE_SYNC",
      path: path
    }, process.env.NEXT_PUBLIC_DRUPAL_BASE_URL);
  }
}

var getMenu = function getMenu(name, options) {
  try {
    var _options;

    options = _extends({
      deserialize: true
    }, options);
    var localePrefix = ((_options = options) == null ? void 0 : _options.locale) && options.locale !== options.defaultLocale ? "/" + options.locale : "";
    var url = buildUrl(localePrefix + "/jsonapi/menu_items/" + name);

    var _fetch2 = fetch,
        _url$toString2 = url.toString();

    return Promise.resolve(buildHeaders(options)).then(function (_buildHeaders) {
      return Promise.resolve(_fetch2(_url$toString2, {
        headers: _buildHeaders
      })).then(function (response) {
        if (!response.ok) {
          throw new Error(response.statusText);
        }

        return Promise.resolve(response.json()).then(function (data) {
          var items = options.deserialize ? deserialize(data) : data;

          var _buildMenuTree = buildMenuTree(items),
              tree = _buildMenuTree.items;

          return {
            items: items,
            tree: tree
          };
        });
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

function buildMenuTree(links, parent) {
  if (parent === void 0) {
    parent = "";
  }

  var children = links.filter(function (link) {
    return link.parent === parent;
  });
  return children.length ? {
    items: children.map(function (link) {
      return _extends({}, link, buildMenuTree(links, link.id));
    })
  } : {};
}

var getResourceCollectionFromContext = function getResourceCollectionFromContext(type, context, options) {
  try {
    options = _extends({
      deserialize: true
    }, options); // // Filter out unpublished entities.
    // if (!context.preview) {
    //   options.params = {
    //     "filter[status]": "1",
    //     ...options.params,
    //   }
    // }

    return Promise.resolve(getResourceCollection(type, _extends({}, options, {
      locale: context.locale,
      defaultLocale: context.defaultLocale
    })));
  } catch (e) {
    return Promise.reject(e);
  }
};
var getResourceCollection = function getResourceCollection(type, options) {
  try {
    var _options, _options2;

    options = _extends({
      deserialize: true
    }, options);
    return Promise.resolve(getJsonApiPathForResourceType(type, ((_options = options) == null ? void 0 : _options.locale) !== ((_options2 = options) == null ? void 0 : _options2.defaultLocale) ? options.locale : undefined)).then(function (apiPath) {
      var _options3;

      if (!apiPath) {
        throw new Error("Error: resource of type " + type + " not found.");
      }

      var url = buildUrl(apiPath, _extends({}, (_options3 = options) == null ? void 0 : _options3.params));

      var _fetch = fetch,
          _url$toString = url.toString();

      return Promise.resolve(buildHeaders(options)).then(function (_buildHeaders) {
        return Promise.resolve(_fetch(_url$toString, {
          headers: _buildHeaders
        })).then(function (response) {
          if (!response.ok) {
            throw new Error(response.statusText);
          }

          return Promise.resolve(response.json()).then(function (json) {
            return options.deserialize ? deserialize(json) : json;
          });
        });
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var getPathsFromContext = function getPathsFromContext(types, context, options) {
  if (options === void 0) {
    options = {};
  }

  try {
    if (typeof types === "string") {
      types = [types];
    }

    return Promise.resolve(Promise.all(types.map(function (type) {
      try {
        var _extends2, _options;

        var _temp3 = function _temp3(_result) {
          return _exit2 ? _result : Promise.resolve(Promise.all(context.locales.map(function (locale) {
            try {
              return Promise.resolve(getResourceCollection(type, _extends({
                deserialize: true,
                locale: locale,
                defaultLocale: context.defaultLocale
              }, options))).then(function (resources) {
                return buildPathsFromResources(resources, locale);
              });
            } catch (e) {
              return Promise.reject(e);
            }
          }))).then(function (paths) {
            return paths.flat();
          });
        };

        var _exit2;

        // Use sparse fieldset to expand max size.
        options.params = _extends((_extends2 = {}, _extends2["fields[" + type + "]"] = "path", _extends2), (_options = options) == null ? void 0 : _options.params); // const paths = await Promise.all(
        //   context.locales.map(async (locale) => {
        //     const resources = await getResourceCollection(type, {
        //       deserialize: true,
        //       locale,
        //       defaultLocale: context.defaultLocale,
        //       ...options,
        //     })
        //     return buildPathsFromResources(resources, locale)
        //   })
        // )
        // return paths.flat()
        // Handle localized path aliases

        var _temp4 = function () {
          var _context$locales;

          if (!((_context$locales = context.locales) == null ? void 0 : _context$locales.length)) {
            return Promise.resolve(getResourceCollection(type, _extends({
              deserialize: true
            }, options))).then(function (resources) {
              _exit2 = 1;
              return buildPathsFromResources(resources);
            });
          }
        }();

        return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));
      } catch (e) {
        return Promise.reject(e);
      }
    }))).then(function (paths) {
      return paths.flat();
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

function buildPathsFromResources(resources, locale) {
  return resources == null ? void 0 : resources.flatMap(function (resource) {
    var _resource$path, _resource$path2;

    var slug = (resource == null ? void 0 : (_resource$path = resource.path) == null ? void 0 : _resource$path.alias) === process.env.DRUPAL_FRONT_PAGE ? "/" : resource == null ? void 0 : (_resource$path2 = resource.path) == null ? void 0 : _resource$path2.alias;
    var path = {
      params: {
        slug: ("" + (slug == null ? void 0 : slug.replace(/^\/|\/$/g, ""))).split("/")
      }
    };

    if (locale) {
      path["locale"] = locale;
    }

    return path;
  });
}

var getResource = function getResource(type, uuid, options) {
  try {
    var _options4, _options5;

    options = _extends({
      deserialize: true,
      params: {}
    }, options);
    return Promise.resolve(getJsonApiPathForResourceType(type, ((_options4 = options) == null ? void 0 : _options4.locale) !== ((_options5 = options) == null ? void 0 : _options5.defaultLocale) ? options.locale : undefined)).then(function (apiPath) {
      var _options6;

      if (!apiPath) {
        throw new Error("Error: resource of type " + type + " not found.");
      }

      var url = buildUrl(apiPath + "/" + uuid, _extends({}, (_options6 = options) == null ? void 0 : _options6.params));

      var _fetch3 = fetch,
          _url$toString3 = url.toString();

      return Promise.resolve(buildHeaders(options)).then(function (_buildHeaders2) {
        return Promise.resolve(_fetch3(_url$toString3, {
          headers: _buildHeaders2
        })).then(function (response) {
          if (!response.ok) {
            throw new Error(response.statusText);
          }

          return Promise.resolve(response.json()).then(function (json) {
            return options.deserialize ? deserialize(json) : json;
          });
        });
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var getResourceByPath = function getResourceByPath(path, options) {
  try {
    var _options3;

    options = _extends({
      deserialize: true,
      isVersionable: false,
      params: {}
    }, options);

    if (!path) {
      return Promise.resolve(null);
    }

    if (options.locale && options.defaultLocale && path.indexOf(options.locale) !== 1) {
      path = path === "/" ? path : path.replace(/^\/+/, "");
      path = getPathFromContext({
        params: {
          slug: [path]
        },
        locale: options.locale,
        defaultLocale: options.defaultLocale
      });
    }

    var _options$params = (_options3 = options) == null ? void 0 : _options3.params,
        _options$params$resou = _options$params.resourceVersion,
        resourceVersion = _options$params$resou === void 0 ? "rel:latest-version" : _options$params$resou,
        params = _objectWithoutPropertiesLoose(_options$params, ["resourceVersion"]);

    var resourceParams = new URLSearchParams(_extends({}, params));

    if (options.isVersionable) {
      resourceParams.set("resourceVersion", resourceVersion);
    }

    var payload = [{
      requestId: "router",
      action: "view",
      uri: "/router/translate-path?path=" + path + "&_format=json",
      headers: {
        Accept: "application/vnd.api+json"
      }
    }, {
      requestId: "resolvedResource",
      action: "view",
      uri: "{{router.body@$.jsonapi.individual}}?" + resourceParams.toString(),
      waitFor: ["router"]
    }]; // Localized subrequests.
    // I was hoping we would not need this but it seems like subrequests is not properly
    // setting the jsonapi locale from a translated path.

    var subrequestsPath = "/subrequests";

    if (options.locale && options.defaultLocale && options.locale !== options.defaultLocale) {
      subrequestsPath = "/" + options.locale + "/subrequests";
    }

    var url = buildUrl(subrequestsPath, {
      _format: "json"
    });

    var _fetch2 = fetch,
        _url$toString2 = url.toString();

    return Promise.resolve(buildHeaders(options)).then(function (_buildHeaders) {
      return Promise.resolve(_fetch2(_url$toString2, {
        method: "POST",
        credentials: "include",
        headers: _buildHeaders,
        redirect: "follow",
        body: JSON.stringify(payload)
      })).then(function (response) {
        if (!response.ok) {
          throw new Error(response.statusText);
        }

        return Promise.resolve(response.json()).then(function (json) {
          var _json$resolvedResourc;

          if (!json["resolvedResource#uri{0}"]) {
            return null;
          }

          var data = JSON.parse((_json$resolvedResourc = json["resolvedResource#uri{0}"]) == null ? void 0 : _json$resolvedResourc.body);

          if (data.errors) {
            throw new Error(data.errors[0].detail);
          }

          return options.deserialize ? deserialize(data) : data;
        });
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var getResourceFromContext = function getResourceFromContext(type, context, options) {
  try {
    var _options, _options2;

    options = _extends({
      deserialize: true,
      // Add support for revisions for node by default.
      // TODO: Make this required before stable?
      isVersionable: /^node--/.test(type)
    }, options);
    var path = getPathFromContext(context, (_options = options) == null ? void 0 : _options.prefix); // Filter out unpublished entities.
    // if (!context.preview) {
    //   options.params = {
    //     "filter[status]": "1",
    //     ...options?.params,
    //   }
    // }

    var previewData = context.previewData;
    return Promise.resolve(getResourceByPath(path, {
      deserialize: options.deserialize,
      isVersionable: options.isVersionable,
      locale: context.locale,
      defaultLocale: context.defaultLocale,
      params: _extends({
        resourceVersion: previewData == null ? void 0 : previewData.resourceVersion
      }, (_options2 = options) == null ? void 0 : _options2.params)
    })).then(function (resource) {
      return !context.locale && !(resource == null ? void 0 : resource.default_langcode) ? null : resource;
    }); // If no locale is passed, skip entity if not default_langcode.
    // This happens because decoupled_router will still translate the path
    // to a resource.
    // TODO: Figure out if we want this behavior.
    // For now this causes a bug where a non-i18n sites builds (ISR) pages for
    // localized pages.
  } catch (e) {
    return Promise.reject(e);
  }
};

var getResourcePreviewUrl = function getResourcePreviewUrl(slug, options) {
  try {
    return Promise.resolve(getResourceByPath(slug, options)).then(function (entity) {
      if (!entity) {
        return null;
      }

      if (!(entity == null ? void 0 : entity.path)) {
        throw new Error("Error: the path attribute is missing for entity type " + entity.type);
      }

      return (entity == null ? void 0 : entity.default_langcode) ? entity.path.alias : "/" + entity.path.langcode + entity.path.alias;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var PreviewHandler = function PreviewHandler(request, response, options) {
  try {
    var _request$query = request.query,
        slug = _request$query.slug,
        resourceVersion = _request$query.resourceVersion,
        secret = _request$query.secret,
        locale = _request$query.locale,
        defaultLocale = _request$query.defaultLocale;

    if (secret !== process.env.DRUPAL_PREVIEW_SECRET) {
      return Promise.resolve(response.status(401).json({
        message: (options == null ? void 0 : options.errorMessages.secret) || "Invalid preview secret."
      }));
    }

    if (!slug) {
      return Promise.resolve(response.status(401).end({
        message: (options == null ? void 0 : options.errorMessages.slug) || "Invalid slug."
      }));
    }

    var _options = {
      isVersionable: typeof resourceVersion !== "undefined"
    };

    if (locale && defaultLocale) {
      _options = _extends({}, _options, {
        locale: locale,
        defaultLocale: defaultLocale
      });
    }

    return Promise.resolve(getResourcePreviewUrl(slug, _options)).then(function (url) {
      if (!url) {
        response.status(404).end({
          message: (options == null ? void 0 : options.errorMessages.slug) || "Invalid slug"
        });
      }

      response.setPreviewData({
        resourceVersion: resourceVersion
      });
      response.writeHead(307, {
        Location: url
      });
      return response.end();
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
function DrupalPreview(options) {
  return function (request, response) {
    return PreviewHandler(request, response, options);
  };
}

var getResourceTypeFromContext = function getResourceTypeFromContext(context, options) {
  try {
    options = _extends({
      prefix: ""
    }, options);
    var url = buildUrl("/router/translate-path", {
      path: getPathFromContext(context, options.prefix)
    });

    var _fetch2 = fetch,
        _url$toString2 = url.toString();

    return Promise.resolve(buildHeaders(options)).then(function (_buildHeaders) {
      return Promise.resolve(_fetch2(_url$toString2, {
        headers: _buildHeaders
      })).then(function (response) {
        if (response.status === 404) {
          return null;
        }

        if (!response.ok) {
          throw new Error(response.statusText);
        }

        return Promise.resolve(response.json()).then(function (json) {
          return json.jsonapi.resourceName;
        });
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var getView = function getView(name, options) {
  try {
    var _options;

    options = _extends({
      deserialize: true
    }, options);
    var localePrefix = ((_options = options) == null ? void 0 : _options.locale) && options.locale !== options.defaultLocale ? "/" + options.locale : "";

    var _name$split = name.split("--"),
        viewId = _name$split[0],
        displayId = _name$split[1];

    var url = buildUrl(localePrefix + "/jsonapi/views/" + viewId + "/" + displayId, options.params);

    var _fetch2 = fetch,
        _url$toString2 = url.toString();

    return Promise.resolve(buildHeaders(options)).then(function (_buildHeaders) {
      return Promise.resolve(_fetch2(_url$toString2, {
        headers: _buildHeaders
      })).then(function (response) {
        if (!response.ok) {
          throw new Error(response.statusText);
        }

        return Promise.resolve(response.json()).then(function (data) {
          var results = options.deserialize ? deserialize(data) : data;
          return {
            results: results,
            meta: data.meta,
            links: data.links
          };
        });
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
}

function useMenu(name) {
  var router = useRouter();

  var _React$useState = useState(null),
      data = _React$useState[0],
      setData = _React$useState[1];

  var _React$useState2 = useState(null),
      error = _React$useState2[0],
      setError = _React$useState2[1];

  var _React$useState3 = useState(false),
      isLoading = _React$useState3[0],
      setIsLoading = _React$useState3[1];

  useEffect(function () {
    var fetchMenuItems = function fetchMenuItems() {
      try {
        setIsLoading(true);

        var _temp2 = _catch(function () {
          return Promise.resolve(getMenu(name, {
            locale: router.locale,
            defaultLocale: router.defaultLocale
          })).then(function (data) {
            setData(data);
            setIsLoading(false);
          });
        }, function (error) {
          setError(error);
          setIsLoading(false);
        });

        return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {}) : void 0);
      } catch (e) {
        return Promise.reject(e);
      }
    };

    fetchMenuItems();
  }, [router.locale]);
  return _extends({}, data, {
    error: error,
    isLoading: isLoading
  });
}

export { DrupalPreview, PreviewHandler, buildUrl, deserialize, getAccessToken, getJsonApiIndex, getJsonApiPathForResourceType, getMenu, getPathsFromContext, getResource, getResourceByPath, getResourceCollection, getResourceCollectionFromContext, getResourceFromContext, getResourcePreviewUrl, getResourceTypeFromContext, getView, syncDrupalPreviewRoutes, useMenu };
//# sourceMappingURL=index.esm.js.map
