import NodeCache from 'node-cache';
import Jsona from 'jsona';
import { stringify } from 'qs';
import { useState, useEffect } from 'react';
import { useRouter } from 'next/router';

const cache = new NodeCache();

const CACHE_KEY = "NEXT_DRUPAL_ACCESS_TOKEN";
async function getAccessToken() {
  if (!process.env.DRUPAL_CLIENT_ID || !process.env.DRUPAL_CLIENT_SECRET) {
    return null;
  }

  const cached = cache.get(CACHE_KEY);

  if (cached == null ? void 0 : cached.access_token) {
    return cached;
  }

  const basic = Buffer.from(`${process.env.DRUPAL_CLIENT_ID}:${process.env.DRUPAL_CLIENT_SECRET}`).toString("base64");
  const response = await fetch(`${process.env.NEXT_PUBLIC_DRUPAL_BASE_URL}/oauth/token`, {
    method: "POST",
    headers: {
      Authorization: `Basic ${basic}`,
      "Content-Type": "application/x-www-form-urlencoded"
    },
    body: `grant_type=client_credentials`
  });

  if (!response.ok) {
    throw new Error(response.statusText);
  }

  const result = await response.json();
  cache.set(CACHE_KEY, result, result.expires_in);
  return result;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

const JSONAPI_PREFIX = process.env.DRUPAL_JSONAPI_PREFIX || "/jsonapi";
const dataFormatter = new Jsona();
function deserialize(body, options) {
  if (!body) return null;
  return dataFormatter.deserialize(body, options);
}
async function getJsonApiPathForResourceType(type, locale) {
  var _index$links$type;

  const index = await getJsonApiIndex(locale);
  return index == null ? void 0 : (_index$links$type = index.links[type]) == null ? void 0 : _index$links$type.href;
}
async function getJsonApiIndex(locale, options) {
  const url = buildUrl(locale ? `/${locale}${JSONAPI_PREFIX}` : `${JSONAPI_PREFIX}`);
  const response = await fetch(url.toString(), {
    headers: await buildHeaders(options)
  });

  if (!response.ok) {
    throw new Error(response.statusText);
  }

  return await response.json();
}
function buildUrl(path, params) {
  const url = new URL(path.charAt(0) === "/" ? `${process.env.NEXT_PUBLIC_DRUPAL_BASE_URL}${path}` : path);

  if (params) {
    // Use instead URLSearchParams for nested params.
    url.search = stringify(params);
  }

  return url;
}
async function buildHeaders({
  accessToken,
  headers = {
    "Content-Type": "application/json"
  }
} = {}) {
  const token = accessToken || (await getAccessToken());

  if (token) {
    headers["Authorization"] = `Bearer ${token.access_token}`;
  }

  return headers;
}
function getPathFromContext(context, prefix = "") {
  let {
    slug
  } = context.params;
  slug = Array.isArray(slug) ? slug.join("/") : slug; // Handle locale.

  if (context.locale && context.locale !== context.defaultLocale) {
    slug = `/${context.locale}/${slug}`;
  }

  return !slug ? process.env.DRUPAL_FRONT_PAGE : prefix ? `${prefix}/${slug}` : slug;
}
function syncDrupalPreviewRoutes(path) {
  if (window && window.top !== window.self) {
    window.parent.postMessage({
      type: "NEXT_DRUPAL_ROUTE_SYNC",
      path
    }, process.env.NEXT_PUBLIC_DRUPAL_BASE_URL);
  }
}

async function getMenu(name, options) {
  var _options;

  options = _extends({
    deserialize: true
  }, options);
  const localePrefix = ((_options = options) == null ? void 0 : _options.locale) && options.locale !== options.defaultLocale ? `/${options.locale}` : "";
  const url = buildUrl(`${localePrefix}/jsonapi/menu_items/${name}`);
  const response = await fetch(url.toString(), {
    headers: await buildHeaders(options)
  });

  if (!response.ok) {
    throw new Error(response.statusText);
  }

  const data = await response.json();
  const items = options.deserialize ? deserialize(data) : data;
  const {
    items: tree
  } = buildMenuTree(items);
  return {
    items,
    tree
  };
}

function buildMenuTree(links, parent = "") {
  const children = links.filter(link => link.parent === parent);
  return children.length ? {
    items: children.map(link => _extends({}, link, buildMenuTree(links, link.id)))
  } : {};
}

async function getResourceCollection(type, options) {
  var _options, _options2, _options3;

  options = _extends({
    deserialize: true
  }, options);
  const apiPath = await getJsonApiPathForResourceType(type, ((_options = options) == null ? void 0 : _options.locale) !== ((_options2 = options) == null ? void 0 : _options2.defaultLocale) ? options.locale : undefined);

  if (!apiPath) {
    throw new Error(`Error: resource of type ${type} not found.`);
  }

  const url = buildUrl(apiPath, _extends({}, (_options3 = options) == null ? void 0 : _options3.params));
  const response = await fetch(url.toString(), {
    headers: await buildHeaders(options)
  });

  if (!response.ok) {
    throw new Error(response.statusText);
  }

  const json = await response.json();
  return options.deserialize ? deserialize(json) : json;
}
async function getResourceCollectionFromContext(type, context, options) {
  options = _extends({
    deserialize: true
  }, options); // // Filter out unpublished entities.
  // if (!context.preview) {
  //   options.params = {
  //     "filter[status]": "1",
  //     ...options.params,
  //   }
  // }

  return await getResourceCollection(type, _extends({}, options, {
    locale: context.locale,
    defaultLocale: context.defaultLocale
  }));
}

async function getPathsFromContext(types, context, options = {}) {
  if (typeof types === "string") {
    types = [types];
  }

  const paths = await Promise.all(types.map(async type => {
    var _context$locales;

    // Use sparse fieldset to expand max size.
    options.params = _extends({
      [`fields[${type}]`]: "path"
    }, options == null ? void 0 : options.params); // const paths = await Promise.all(
    //   context.locales.map(async (locale) => {
    //     const resources = await getResourceCollection(type, {
    //       deserialize: true,
    //       locale,
    //       defaultLocale: context.defaultLocale,
    //       ...options,
    //     })
    //     return buildPathsFromResources(resources, locale)
    //   })
    // )
    // return paths.flat()
    // Handle localized path aliases

    if (!((_context$locales = context.locales) == null ? void 0 : _context$locales.length)) {
      const resources = await getResourceCollection(type, _extends({
        deserialize: true
      }, options));
      return buildPathsFromResources(resources);
    }

    const paths = await Promise.all(context.locales.map(async locale => {
      const resources = await getResourceCollection(type, _extends({
        deserialize: true,
        locale,
        defaultLocale: context.defaultLocale
      }, options));
      return buildPathsFromResources(resources, locale);
    }));
    return paths.flat();
  }));
  return paths.flat();
}

function buildPathsFromResources(resources, locale) {
  return resources == null ? void 0 : resources.flatMap(resource => {
    var _resource$path, _resource$path2;

    const slug = (resource == null ? void 0 : (_resource$path = resource.path) == null ? void 0 : _resource$path.alias) === process.env.DRUPAL_FRONT_PAGE ? "/" : resource == null ? void 0 : (_resource$path2 = resource.path) == null ? void 0 : _resource$path2.alias;
    const path = {
      params: {
        slug: `${slug == null ? void 0 : slug.replace(/^\/|\/$/g, "")}`.split("/")
      }
    };

    if (locale) {
      path["locale"] = locale;
    }

    return path;
  });
}

async function getResourceFromContext(type, context, options) {
  var _options, _options2;

  options = _extends({
    deserialize: true,
    // Add support for revisions for node by default.
    // TODO: Make this required before stable?
    isVersionable: /^node--/.test(type)
  }, options);
  const path = getPathFromContext(context, (_options = options) == null ? void 0 : _options.prefix); // Filter out unpublished entities.
  // if (!context.preview) {
  //   options.params = {
  //     "filter[status]": "1",
  //     ...options?.params,
  //   }
  // }

  const previewData = context.previewData;
  const resource = await getResourceByPath(path, {
    deserialize: options.deserialize,
    isVersionable: options.isVersionable,
    locale: context.locale,
    defaultLocale: context.defaultLocale,
    params: _extends({
      resourceVersion: previewData == null ? void 0 : previewData.resourceVersion
    }, (_options2 = options) == null ? void 0 : _options2.params)
  }); // If no locale is passed, skip entity if not default_langcode.
  // This happens because decoupled_router will still translate the path
  // to a resource.
  // TODO: Figure out if we want this behavior.
  // For now this causes a bug where a non-i18n sites builds (ISR) pages for
  // localized pages.

  if (!context.locale && !(resource == null ? void 0 : resource.default_langcode)) {
    return null;
  }

  return resource;
}
async function getResourceByPath(path, options) {
  var _options3, _json$resolvedResourc;

  options = _extends({
    deserialize: true,
    isVersionable: false,
    params: {}
  }, options);

  if (!path) {
    return null;
  }

  if (options.locale && options.defaultLocale && path.indexOf(options.locale) !== 1) {
    path = path === "/" ? path : path.replace(/^\/+/, "");
    path = getPathFromContext({
      params: {
        slug: [path]
      },
      locale: options.locale,
      defaultLocale: options.defaultLocale
    });
  }

  const _options$params = (_options3 = options) == null ? void 0 : _options3.params,
        {
    resourceVersion = "rel:latest-version"
  } = _options$params,
        params = _objectWithoutPropertiesLoose(_options$params, ["resourceVersion"]);

  const resourceParams = new URLSearchParams(_extends({}, params));

  if (options.isVersionable) {
    resourceParams.set("resourceVersion", resourceVersion);
  }

  const payload = [{
    requestId: "router",
    action: "view",
    uri: `/router/translate-path?path=${path}&_format=json`,
    headers: {
      Accept: "application/vnd.api+json"
    }
  }, {
    requestId: "resolvedResource",
    action: "view",
    uri: `{{router.body@$.jsonapi.individual}}?${resourceParams.toString()}`,
    waitFor: ["router"]
  }]; // Localized subrequests.
  // I was hoping we would not need this but it seems like subrequests is not properly
  // setting the jsonapi locale from a translated path.

  let subrequestsPath = "/subrequests";

  if (options.locale && options.defaultLocale && options.locale !== options.defaultLocale) {
    subrequestsPath = `/${options.locale}/subrequests`;
  }

  const url = buildUrl(subrequestsPath, {
    _format: "json"
  });
  const response = await fetch(url.toString(), {
    method: "POST",
    credentials: "include",
    headers: await buildHeaders(options),
    redirect: "follow",
    body: JSON.stringify(payload)
  });

  if (!response.ok) {
    throw new Error(response.statusText);
  }

  const json = await response.json();

  if (!json["resolvedResource#uri{0}"]) {
    return null;
  }

  const data = JSON.parse((_json$resolvedResourc = json["resolvedResource#uri{0}"]) == null ? void 0 : _json$resolvedResourc.body);

  if (data.errors) {
    throw new Error(data.errors[0].detail);
  }

  return options.deserialize ? deserialize(data) : data;
}
async function getResource(type, uuid, options) {
  var _options4, _options5, _options6;

  options = _extends({
    deserialize: true,
    params: {}
  }, options);
  const apiPath = await getJsonApiPathForResourceType(type, ((_options4 = options) == null ? void 0 : _options4.locale) !== ((_options5 = options) == null ? void 0 : _options5.defaultLocale) ? options.locale : undefined);

  if (!apiPath) {
    throw new Error(`Error: resource of type ${type} not found.`);
  }

  const url = buildUrl(`${apiPath}/${uuid}`, _extends({}, (_options6 = options) == null ? void 0 : _options6.params));
  const response = await fetch(url.toString(), {
    headers: await buildHeaders(options)
  });

  if (!response.ok) {
    throw new Error(response.statusText);
  }

  const json = await response.json();
  return options.deserialize ? deserialize(json) : json;
}

function DrupalPreview(options) {
  return (request, response) => PreviewHandler(request, response, options);
}
async function PreviewHandler(request, response, options) {
  const {
    slug,
    resourceVersion,
    secret,
    locale,
    defaultLocale
  } = request.query;

  if (secret !== process.env.DRUPAL_PREVIEW_SECRET) {
    return response.status(401).json({
      message: (options == null ? void 0 : options.errorMessages.secret) || "Invalid preview secret."
    });
  }

  if (!slug) {
    return response.status(401).end({
      message: (options == null ? void 0 : options.errorMessages.slug) || "Invalid slug."
    });
  }

  let _options = {
    isVersionable: typeof resourceVersion !== "undefined"
  };

  if (locale && defaultLocale) {
    _options = _extends({}, _options, {
      locale: locale,
      defaultLocale: defaultLocale
    });
  }

  const url = await getResourcePreviewUrl(slug, _options);

  if (!url) {
    response.status(404).end({
      message: (options == null ? void 0 : options.errorMessages.slug) || "Invalid slug"
    });
  }

  response.setPreviewData({
    resourceVersion
  });
  response.writeHead(307, {
    Location: url
  });
  return response.end();
}
async function getResourcePreviewUrl(slug, options) {
  const entity = await getResourceByPath(slug, options);

  if (!entity) {
    return null;
  }

  if (!(entity == null ? void 0 : entity.path)) {
    throw new Error(`Error: the path attribute is missing for entity type ${entity.type}`);
  }

  return (entity == null ? void 0 : entity.default_langcode) ? entity.path.alias : `/${entity.path.langcode}${entity.path.alias}`;
}

async function getResourceTypeFromContext(context, options) {
  options = _extends({
    prefix: ""
  }, options);
  const url = buildUrl("/router/translate-path", {
    path: getPathFromContext(context, options.prefix)
  });
  const response = await fetch(url.toString(), {
    headers: await buildHeaders(options)
  });

  if (response.status === 404) {
    return null;
  }

  if (!response.ok) {
    throw new Error(response.statusText);
  }

  const json = await response.json();
  return json.jsonapi.resourceName;
}

async function getView(name, options) {
  var _options;

  options = _extends({
    deserialize: true
  }, options);
  const localePrefix = ((_options = options) == null ? void 0 : _options.locale) && options.locale !== options.defaultLocale ? `/${options.locale}` : "";
  const [viewId, displayId] = name.split("--");
  const url = buildUrl(`${localePrefix}/jsonapi/views/${viewId}/${displayId}`, options.params);
  const response = await fetch(url.toString(), {
    headers: await buildHeaders(options)
  });

  if (!response.ok) {
    throw new Error(response.statusText);
  }

  const data = await response.json();
  const results = options.deserialize ? deserialize(data) : data;
  return {
    results,
    meta: data.meta,
    links: data.links
  };
}

function useMenu(name) {
  const router = useRouter();
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  useEffect(() => {
    const fetchMenuItems = async () => {
      setIsLoading(true);

      try {
        const data = await getMenu(name, {
          locale: router.locale,
          defaultLocale: router.defaultLocale
        });
        setData(data);
        setIsLoading(false);
      } catch (error) {
        setError(error);
        setIsLoading(false);
      }
    };

    fetchMenuItems();
  }, [router.locale]);
  return _extends({}, data, {
    error,
    isLoading
  });
}

export { DrupalPreview, PreviewHandler, buildUrl, deserialize, getAccessToken, getJsonApiIndex, getJsonApiPathForResourceType, getMenu, getPathsFromContext, getResource, getResourceByPath, getResourceCollection, getResourceCollectionFromContext, getResourceFromContext, getResourcePreviewUrl, getResourceTypeFromContext, getView, syncDrupalPreviewRoutes, useMenu };
//# sourceMappingURL=index.modern.js.map
